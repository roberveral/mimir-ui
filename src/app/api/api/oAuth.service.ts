/**
 * OAuth Authorization Server API
 * Definition of the REST API exported by the OAuth Authorization Server.
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { JWKSet } from '../model/jWKSet.model';
import { OAuthAuthorizeResponse } from '../model/oAuthAuthorizeResponse.model';
import { OAuthTokenResponse } from '../model/oAuthTokenResponse.model';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class OAuthService {

    protected basePath = 'http://localhost:8000/v0';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Authorizes a client to act on behalf of the user in the Authorization Code OAuth flow.
     * This endpoint performs the first step in the OAuth 2 Authorization Code flow. When a call to this endpoint is performed by an authenticated user, it means that the user is authorizing the client defined by the client_id to act on his behalf and therefore to obtain an access token. https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/ The frontend MUST redirect the user to the returned redirect_uri in order to continue with the authorization flow. The server supports the PKCE Extension so clients which can&#39;t keep a secret can obtain an access token by passing a random secret as a code_challenge in the Authorization request which then the server verifies when trying to obtain the access token, identifying that the auhtorization code belongs to the right client. https://www.oauth.com/oauth2-servers/pkce/authorization-request/ 
     * @param responseType Indicates that the client expects to receive an authorization code.
     * @param clientId The client_id received when the client was registered.
     * @param redirectUri Indicates the URI to return the user to after authorization is complete.
     * @param scope One or more scope values indicating which parts of the user&#39;s account the client wish to access.
     * @param state A client provided string which will be returned to the client in the callback endpoint, and can be used to store session information.
     * @param codeChallenge (PKCE Extension) Optional code challenge generated by the client so it can  avoid sending the client_secret to request a token. The client generates a  \&quot;code verifier\&quot; as a random string and then it sends this code verifier either as a Base64 URL encoded SHA-256 hash or as plain text. This code will be sent again in the token request to ensure that the request comes from the authorized client. 
     * @param codeChallengeMethod (PKCE Extension) Optional method for the given code challenge. It can either be &#39;plain&#39; (the client has sent the code verifier) or &#39;S256&#39; (the client has sent a Base64 URL encoded SHA-256 hash of the code verifier) 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authorizeOAuthClient(responseType: 'code', clientId: string, redirectUri?: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: 'S256' | 'plain', observe?: 'body', reportProgress?: boolean): Observable<OAuthAuthorizeResponse>;
    public authorizeOAuthClient(responseType: 'code', clientId: string, redirectUri?: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: 'S256' | 'plain', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OAuthAuthorizeResponse>>;
    public authorizeOAuthClient(responseType: 'code', clientId: string, redirectUri?: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: 'S256' | 'plain', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OAuthAuthorizeResponse>>;
    public authorizeOAuthClient(responseType: 'code', clientId: string, redirectUri?: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: 'S256' | 'plain', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (responseType === null || responseType === undefined) {
            throw new Error('Required parameter responseType was null or undefined when calling authorizeOAuthClient.');
        }
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling authorizeOAuthClient.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (responseType !== undefined && responseType !== null) {
            queryParameters = queryParameters.set('response_type', <any>responseType);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        if (redirectUri !== undefined && redirectUri !== null) {
            queryParameters = queryParameters.set('redirect_uri', <any>redirectUri);
        }
        if (scope !== undefined && scope !== null) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (state !== undefined && state !== null) {
            queryParameters = queryParameters.set('state', <any>state);
        }
        if (codeChallenge !== undefined && codeChallenge !== null) {
            queryParameters = queryParameters.set('code_challenge', <any>codeChallenge);
        }
        if (codeChallengeMethod !== undefined && codeChallengeMethod !== null) {
            queryParameters = queryParameters.set('code_challenge_method', <any>codeChallengeMethod);
        }

        let headers = this.defaultHeaders;

        // authentication (apiAuthentication) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<OAuthAuthorizeResponse>(`${this.configuration.basePath}/oauth/authorize`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtains the JWK specification of the keys used to sign tokens.
     * Obtains the JWK (JSON Web Key) set with the keys used to sign access tokens, so resource servers can get it from here in order to validate that the tokens have been issued by the Authorization Server. https://tools.ietf.org/html/rfc7517 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJKWS(observe?: 'body', reportProgress?: boolean): Observable<JWKSet>;
    public getJKWS(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JWKSet>>;
    public getJKWS(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JWKSet>>;
    public getJKWS(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<JWKSet>(`${this.configuration.basePath}/oauth/jwks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Allows a client to obtain an access token to access protected resources.
     * This endpoint allows a client to request an access token in order to access protected resources. Depending on the grant_type, this token can be to act on behalf of a given user or by the client itself. https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/ https://www.oauth.com/oauth2-servers/access-tokens/password-grant/ https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/ This endpoint supports the PKCE Extension so clients who can&#39;t store a client can obtain an access token. https://www.oauth.com/oauth2-servers/pkce/authorization-code-exchange/ The access token is a JWT token signed with the public key of the authorization server and which contains the following information.   - sub (username or client_id, depending on the entity which holds the permission).   - cid (client who acts on behalf of the subject).   - name (name of the authenticated user).   - email (email of the authenticated user).   - picture (url to the user profile picture).    Resource servers can verify the token integrity and expiration and get the requesting user from this token. The public key used to sign the token can be obtained from the /oauth/jwks endpoint, with the kid &#39;access_token&#39;. 
     * @param grantType The grant type for the Authentication Flow required.
     * @param clientId Unique identifier of the client that requests the access token.
     * @param code Authorization Code received by the Authorize phase. (Authorization Code Flow - REQUIRED)
     * @param redirectUri Must be identical to the redirect URI used in the Authorization phase. (Authorization Code Flow - REQUIRED)
     * @param clientSecret The client’s secret. This ensures that the request to get the access token is made only from the client. (Authorization Code Flow - OPTIONAL, Client Credentials Flow - REQUIRED)
     * @param username The user’s username that they entered in the client application. (Password Flow - REQUIRED)
     * @param password The user’s password that they entered in the client application. (Password Flow - REQUIRED)
     * @param codeVerifier The code verifier for the PKCE request that the app originally generated before the authorization request. (Authorization Code Flow - OPTIONAL)
     * @param scope One or more scope values indicating which parts of the user&#39;s account the client wish to access. (Password and Client Credentials Flows - OPTIONAL)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOAuthToken(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, username?: string, password?: string, codeVerifier?: string, scope?: string, observe?: 'body', reportProgress?: boolean): Observable<OAuthTokenResponse>;
    public getOAuthToken(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, username?: string, password?: string, codeVerifier?: string, scope?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OAuthTokenResponse>>;
    public getOAuthToken(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, username?: string, password?: string, codeVerifier?: string, scope?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OAuthTokenResponse>>;
    public getOAuthToken(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, username?: string, password?: string, codeVerifier?: string, scope?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling getOAuthToken.');
        }
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getOAuthToken.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-www-form-urlencoded'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (grantType !== undefined) {
            formParams = formParams.append('grant_type', <any>grantType) as any || formParams;
        }
        if (code !== undefined) {
            formParams = formParams.append('code', <any>code) as any || formParams;
        }
        if (redirectUri !== undefined) {
            formParams = formParams.append('redirect_uri', <any>redirectUri) as any || formParams;
        }
        if (clientId !== undefined) {
            formParams = formParams.append('client_id', <any>clientId) as any || formParams;
        }
        if (clientSecret !== undefined) {
            formParams = formParams.append('client_secret', <any>clientSecret) as any || formParams;
        }
        if (username !== undefined) {
            formParams = formParams.append('username', <any>username) as any || formParams;
        }
        if (password !== undefined) {
            formParams = formParams.append('password', <any>password) as any || formParams;
        }
        if (codeVerifier !== undefined) {
            formParams = formParams.append('code_verifier', <any>codeVerifier) as any || formParams;
        }
        if (scope !== undefined) {
            formParams = formParams.append('scope', <any>scope) as any || formParams;
        }

        return this.httpClient.post<OAuthTokenResponse>(`${this.configuration.basePath}/oauth/token`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
